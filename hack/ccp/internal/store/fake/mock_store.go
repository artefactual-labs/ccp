// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/store/store.go
//
// Generated by this command:
//
//	mockgen -typed -source=./internal/store/store.go -destination=./internal/store/fake/mock_store.go -package=fake Store
//

// Package fake is a generated GoMock package.
package fake

import (
	context "context"
	reflect "reflect"

	store "github.com/artefactual/archivematica/hack/ccp/internal/store"
	sqlcmysql "github.com/artefactual/archivematica/hack/ccp/internal/store/sqlcmysql"
	uuid "github.com/google/uuid"
	gomock "go.uber.org/mock/gomock"
)

// MockStore is a mock of Store interface.
type MockStore struct {
	ctrl     *gomock.Controller
	recorder *MockStoreMockRecorder
}

// MockStoreMockRecorder is the mock recorder for MockStore.
type MockStoreMockRecorder struct {
	mock *MockStore
}

// NewMockStore creates a new mock instance.
func NewMockStore(ctrl *gomock.Controller) *MockStore {
	mock := &MockStore{ctrl: ctrl}
	mock.recorder = &MockStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStore) EXPECT() *MockStoreMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockStore) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockStoreMockRecorder) Close() *MockStoreCloseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockStore)(nil).Close))
	return &MockStoreCloseCall{Call: call}
}

// MockStoreCloseCall wrap *gomock.Call
type MockStoreCloseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreCloseCall) Return(arg0 error) *MockStoreCloseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreCloseCall) Do(f func() error) *MockStoreCloseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreCloseCall) DoAndReturn(f func() error) *MockStoreCloseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateJob mocks base method.
func (m *MockStore) CreateJob(ctx context.Context, params *sqlcmysql.CreateJobParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateJob", ctx, params)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateJob indicates an expected call of CreateJob.
func (mr *MockStoreMockRecorder) CreateJob(ctx, params any) *MockStoreCreateJobCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateJob", reflect.TypeOf((*MockStore)(nil).CreateJob), ctx, params)
	return &MockStoreCreateJobCall{Call: call}
}

// MockStoreCreateJobCall wrap *gomock.Call
type MockStoreCreateJobCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreCreateJobCall) Return(arg0 error) *MockStoreCreateJobCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreCreateJobCall) Do(f func(context.Context, *sqlcmysql.CreateJobParams) error) *MockStoreCreateJobCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreCreateJobCall) DoAndReturn(f func(context.Context, *sqlcmysql.CreateJobParams) error) *MockStoreCreateJobCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateUnitVar mocks base method.
func (m *MockStore) CreateUnitVar(ctx context.Context, id uuid.UUID, packageType, name, value string, linkID uuid.UUID, update bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateUnitVar", ctx, id, packageType, name, value, linkID, update)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateUnitVar indicates an expected call of CreateUnitVar.
func (mr *MockStoreMockRecorder) CreateUnitVar(ctx, id, packageType, name, value, linkID, update any) *MockStoreCreateUnitVarCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUnitVar", reflect.TypeOf((*MockStore)(nil).CreateUnitVar), ctx, id, packageType, name, value, linkID, update)
	return &MockStoreCreateUnitVarCall{Call: call}
}

// MockStoreCreateUnitVarCall wrap *gomock.Call
type MockStoreCreateUnitVarCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreCreateUnitVarCall) Return(arg0 error) *MockStoreCreateUnitVarCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreCreateUnitVarCall) Do(f func(context.Context, uuid.UUID, string, string, string, uuid.UUID, bool) error) *MockStoreCreateUnitVarCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreCreateUnitVarCall) DoAndReturn(f func(context.Context, uuid.UUID, string, string, string, uuid.UUID, bool) error) *MockStoreCreateUnitVarCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// EnsureTransfer mocks base method.
func (m *MockStore) EnsureTransfer(ctx context.Context, path string) (uuid.UUID, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EnsureTransfer", ctx, path)
	ret0, _ := ret[0].(uuid.UUID)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// EnsureTransfer indicates an expected call of EnsureTransfer.
func (mr *MockStoreMockRecorder) EnsureTransfer(ctx, path any) *MockStoreEnsureTransferCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnsureTransfer", reflect.TypeOf((*MockStore)(nil).EnsureTransfer), ctx, path)
	return &MockStoreEnsureTransferCall{Call: call}
}

// MockStoreEnsureTransferCall wrap *gomock.Call
type MockStoreEnsureTransferCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreEnsureTransferCall) Return(id uuid.UUID, created bool, err error) *MockStoreEnsureTransferCall {
	c.Call = c.Call.Return(id, created, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreEnsureTransferCall) Do(f func(context.Context, string) (uuid.UUID, bool, error)) *MockStoreEnsureTransferCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreEnsureTransferCall) DoAndReturn(f func(context.Context, string) (uuid.UUID, bool, error)) *MockStoreEnsureTransferCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadTransferLocation mocks base method.
func (m *MockStore) ReadTransferLocation(ctx context.Context, id uuid.UUID) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadTransferLocation", ctx, id)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadTransferLocation indicates an expected call of ReadTransferLocation.
func (mr *MockStoreMockRecorder) ReadTransferLocation(ctx, id any) *MockStoreReadTransferLocationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadTransferLocation", reflect.TypeOf((*MockStore)(nil).ReadTransferLocation), ctx, id)
	return &MockStoreReadTransferLocationCall{Call: call}
}

// MockStoreReadTransferLocationCall wrap *gomock.Call
type MockStoreReadTransferLocationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreReadTransferLocationCall) Return(loc string, err error) *MockStoreReadTransferLocationCall {
	c.Call = c.Call.Return(loc, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreReadTransferLocationCall) Do(f func(context.Context, uuid.UUID) (string, error)) *MockStoreReadTransferLocationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreReadTransferLocationCall) DoAndReturn(f func(context.Context, uuid.UUID) (string, error)) *MockStoreReadTransferLocationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadUnitLinkID mocks base method.
func (m *MockStore) ReadUnitLinkID(ctx context.Context, id uuid.UUID, packageType, name string) (uuid.UUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadUnitLinkID", ctx, id, packageType, name)
	ret0, _ := ret[0].(uuid.UUID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadUnitLinkID indicates an expected call of ReadUnitLinkID.
func (mr *MockStoreMockRecorder) ReadUnitLinkID(ctx, id, packageType, name any) *MockStoreReadUnitLinkIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadUnitLinkID", reflect.TypeOf((*MockStore)(nil).ReadUnitLinkID), ctx, id, packageType, name)
	return &MockStoreReadUnitLinkIDCall{Call: call}
}

// MockStoreReadUnitLinkIDCall wrap *gomock.Call
type MockStoreReadUnitLinkIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreReadUnitLinkIDCall) Return(arg0 uuid.UUID, arg1 error) *MockStoreReadUnitLinkIDCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreReadUnitLinkIDCall) Do(f func(context.Context, uuid.UUID, string, string) (uuid.UUID, error)) *MockStoreReadUnitLinkIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreReadUnitLinkIDCall) DoAndReturn(f func(context.Context, uuid.UUID, string, string) (uuid.UUID, error)) *MockStoreReadUnitLinkIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadUnitVar mocks base method.
func (m *MockStore) ReadUnitVar(ctx context.Context, id uuid.UUID, packageType, name string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadUnitVar", ctx, id, packageType, name)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadUnitVar indicates an expected call of ReadUnitVar.
func (mr *MockStoreMockRecorder) ReadUnitVar(ctx, id, packageType, name any) *MockStoreReadUnitVarCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadUnitVar", reflect.TypeOf((*MockStore)(nil).ReadUnitVar), ctx, id, packageType, name)
	return &MockStoreReadUnitVarCall{Call: call}
}

// MockStoreReadUnitVarCall wrap *gomock.Call
type MockStoreReadUnitVarCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreReadUnitVarCall) Return(arg0 string, arg1 error) *MockStoreReadUnitVarCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreReadUnitVarCall) Do(f func(context.Context, uuid.UUID, string, string) (string, error)) *MockStoreReadUnitVarCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreReadUnitVarCall) DoAndReturn(f func(context.Context, uuid.UUID, string, string) (string, error)) *MockStoreReadUnitVarCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadUnitVars mocks base method.
func (m *MockStore) ReadUnitVars(ctx context.Context, id uuid.UUID, packageType, name string) ([]store.UnitVar, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadUnitVars", ctx, id, packageType, name)
	ret0, _ := ret[0].([]store.UnitVar)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadUnitVars indicates an expected call of ReadUnitVars.
func (mr *MockStoreMockRecorder) ReadUnitVars(ctx, id, packageType, name any) *MockStoreReadUnitVarsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadUnitVars", reflect.TypeOf((*MockStore)(nil).ReadUnitVars), ctx, id, packageType, name)
	return &MockStoreReadUnitVarsCall{Call: call}
}

// MockStoreReadUnitVarsCall wrap *gomock.Call
type MockStoreReadUnitVarsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreReadUnitVarsCall) Return(arg0 []store.UnitVar, arg1 error) *MockStoreReadUnitVarsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreReadUnitVarsCall) Do(f func(context.Context, uuid.UUID, string, string) ([]store.UnitVar, error)) *MockStoreReadUnitVarsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreReadUnitVarsCall) DoAndReturn(f func(context.Context, uuid.UUID, string, string) ([]store.UnitVar, error)) *MockStoreReadUnitVarsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RemoveTransientData mocks base method.
func (m *MockStore) RemoveTransientData(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveTransientData", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveTransientData indicates an expected call of RemoveTransientData.
func (mr *MockStoreMockRecorder) RemoveTransientData(ctx any) *MockStoreRemoveTransientDataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveTransientData", reflect.TypeOf((*MockStore)(nil).RemoveTransientData), ctx)
	return &MockStoreRemoveTransientDataCall{Call: call}
}

// MockStoreRemoveTransientDataCall wrap *gomock.Call
type MockStoreRemoveTransientDataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreRemoveTransientDataCall) Return(arg0 error) *MockStoreRemoveTransientDataCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreRemoveTransientDataCall) Do(f func(context.Context) error) *MockStoreRemoveTransientDataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreRemoveTransientDataCall) DoAndReturn(f func(context.Context) error) *MockStoreRemoveTransientDataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Running mocks base method.
func (m *MockStore) Running() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Running")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Running indicates an expected call of Running.
func (mr *MockStoreMockRecorder) Running() *MockStoreRunningCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Running", reflect.TypeOf((*MockStore)(nil).Running))
	return &MockStoreRunningCall{Call: call}
}

// MockStoreRunningCall wrap *gomock.Call
type MockStoreRunningCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreRunningCall) Return(arg0 bool) *MockStoreRunningCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreRunningCall) Do(f func() bool) *MockStoreRunningCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreRunningCall) DoAndReturn(f func() bool) *MockStoreRunningCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateJobStatus mocks base method.
func (m *MockStore) UpdateJobStatus(ctx context.Context, id uuid.UUID, status string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateJobStatus", ctx, id, status)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateJobStatus indicates an expected call of UpdateJobStatus.
func (mr *MockStoreMockRecorder) UpdateJobStatus(ctx, id, status any) *MockStoreUpdateJobStatusCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateJobStatus", reflect.TypeOf((*MockStore)(nil).UpdateJobStatus), ctx, id, status)
	return &MockStoreUpdateJobStatusCall{Call: call}
}

// MockStoreUpdateJobStatusCall wrap *gomock.Call
type MockStoreUpdateJobStatusCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreUpdateJobStatusCall) Return(arg0 error) *MockStoreUpdateJobStatusCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreUpdateJobStatusCall) Do(f func(context.Context, uuid.UUID, string) error) *MockStoreUpdateJobStatusCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreUpdateJobStatusCall) DoAndReturn(f func(context.Context, uuid.UUID, string) error) *MockStoreUpdateJobStatusCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateUnitStatus mocks base method.
func (m *MockStore) UpdateUnitStatus(ctx context.Context, id uuid.UUID, unitType, status string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateUnitStatus", ctx, id, unitType, status)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateUnitStatus indicates an expected call of UpdateUnitStatus.
func (mr *MockStoreMockRecorder) UpdateUnitStatus(ctx, id, unitType, status any) *MockStoreUpdateUnitStatusCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateUnitStatus", reflect.TypeOf((*MockStore)(nil).UpdateUnitStatus), ctx, id, unitType, status)
	return &MockStoreUpdateUnitStatusCall{Call: call}
}

// MockStoreUpdateUnitStatusCall wrap *gomock.Call
type MockStoreUpdateUnitStatusCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreUpdateUnitStatusCall) Return(arg0 error) *MockStoreUpdateUnitStatusCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreUpdateUnitStatusCall) Do(f func(context.Context, uuid.UUID, string, string) error) *MockStoreUpdateUnitStatusCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreUpdateUnitStatusCall) DoAndReturn(f func(context.Context, uuid.UUID, string, string) error) *MockStoreUpdateUnitStatusCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpsertTransfer mocks base method.
func (m *MockStore) UpsertTransfer(ctx context.Context, id uuid.UUID, path string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpsertTransfer", ctx, id, path)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpsertTransfer indicates an expected call of UpsertTransfer.
func (mr *MockStoreMockRecorder) UpsertTransfer(ctx, id, path any) *MockStoreUpsertTransferCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertTransfer", reflect.TypeOf((*MockStore)(nil).UpsertTransfer), ctx, id, path)
	return &MockStoreUpsertTransferCall{Call: call}
}

// MockStoreUpsertTransferCall wrap *gomock.Call
type MockStoreUpsertTransferCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreUpsertTransferCall) Return(created bool, err error) *MockStoreUpsertTransferCall {
	c.Call = c.Call.Return(created, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreUpsertTransferCall) Do(f func(context.Context, uuid.UUID, string) (bool, error)) *MockStoreUpsertTransferCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreUpsertTransferCall) DoAndReturn(f func(context.Context, uuid.UUID, string) (bool, error)) *MockStoreUpsertTransferCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
