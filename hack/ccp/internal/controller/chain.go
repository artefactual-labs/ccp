package controller

import "github.com/artefactual/archivematica/hack/ccp/internal/workflow"

// A chain is used for passing information between jobs.
//
// In Archivematica the workflow is structured around chains and links.
// A chain is a sequence of links used to accomplish a broader task or set of
// tasks, carrying local state relevant only for the duration of the chain.
// The output of a chain is placed in a watched directory to trigger the next
// chain.
//
// In MCPServer, `chain.jobChain` is implemented as an iterator, simplifying
// the process of moving through the jobs in a chain. When a chain completes,
// the queue manager checks the queues for ay work awaiting to be processed,
// which could be related to other packages.
//
// In a3m, chains and watched directories were removed, but it's hard to do it
// without introducing backward-incompatible changes given the reliance on it
// in some edge cases like reingest, etc.
type chain struct {
	// The properties of the chain as described by the workflow document.
	wc *workflow.Chain

	// A map of replacement variables for tasks.
	// TODO: why are we not using replacementMappings instead?
	context *packageContext

	// choices is a list of choices available from script output, e.g. available
	// storage service locations. Choices are generated by outputClientScriptJob
	// and presented as decision points using via outputDecisionJob.
	choices []choice
}

// update the context of the chain with a new map.
func (c *chain) update(kvs map[string]string) {
	for k, v := range kvs {
		c.context.Set(k, string(v))
	}
}
