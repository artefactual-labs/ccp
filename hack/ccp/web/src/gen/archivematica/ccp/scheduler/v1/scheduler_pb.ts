// @generated by protoc-gen-es v1.9.0 with parameter "target=ts"
// @generated from file archivematica/ccp/scheduler/v1/scheduler.proto (package archivematica.ccp.scheduler.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * WorkRequest is sent by the worker.
 *
 * @generated from message archivematica.ccp.scheduler.v1.WorkRequest
 */
export class WorkRequest extends Message<WorkRequest> {
  /**
   * @generated from oneof archivematica.ccp.scheduler.v1.WorkRequest.request
   */
  request: {
    /**
     * CAN_DO - notify the scheduler that the worker is able to perform the given function.
     *
     * @generated from field: archivematica.ccp.scheduler.v1.WorkRequest.CanDo can_do = 1;
     */
    value: WorkRequest_CanDo;
    case: "canDo";
  } | {
    /**
     * PRE_SLEEP - notify the scheduler that the worker is about to sleep, and that it should be woken up with a NOOP.
     *
     * @generated from field: archivematica.ccp.scheduler.v1.WorkRequest.PreSleep pre_sleep = 2;
     */
    value: WorkRequest_PreSleep;
    case: "preSleep";
  } | {
    /**
     * GRAB_JOB - request the scheduler any available jobs on the queue. The server will respond with either NO_JOB or JOB_ASSIGN.
     *
     * @generated from field: archivematica.ccp.scheduler.v1.WorkRequest.GrabJob grab_job = 3;
     */
    value: WorkRequest_GrabJob;
    case: "grabJob";
  } | {
    /**
     * SET_CLIENT_ID - sents the worker ID in the scheduler.
     *
     * @generated from field: archivematica.ccp.scheduler.v1.WorkRequest.SetClientId set_client_id = 4;
     */
    value: WorkRequest_SetClientId;
    case: "setClientId";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<WorkRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "archivematica.ccp.scheduler.v1.WorkRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "can_do", kind: "message", T: WorkRequest_CanDo, oneof: "request" },
    { no: 2, name: "pre_sleep", kind: "message", T: WorkRequest_PreSleep, oneof: "request" },
    { no: 3, name: "grab_job", kind: "message", T: WorkRequest_GrabJob, oneof: "request" },
    { no: 4, name: "set_client_id", kind: "message", T: WorkRequest_SetClientId, oneof: "request" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkRequest {
    return new WorkRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkRequest {
    return new WorkRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkRequest {
    return new WorkRequest().fromJsonString(jsonString, options);
  }

  static equals(a: WorkRequest | PlainMessage<WorkRequest> | undefined, b: WorkRequest | PlainMessage<WorkRequest> | undefined): boolean {
    return proto3.util.equals(WorkRequest, a, b);
  }
}

/**
 * @generated from message archivematica.ccp.scheduler.v1.WorkRequest.CanDo
 */
export class WorkRequest_CanDo extends Message<WorkRequest_CanDo> {
  /**
   * @generated from field: string function = 1;
   */
  function = "";

  constructor(data?: PartialMessage<WorkRequest_CanDo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "archivematica.ccp.scheduler.v1.WorkRequest.CanDo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "function", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkRequest_CanDo {
    return new WorkRequest_CanDo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkRequest_CanDo {
    return new WorkRequest_CanDo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkRequest_CanDo {
    return new WorkRequest_CanDo().fromJsonString(jsonString, options);
  }

  static equals(a: WorkRequest_CanDo | PlainMessage<WorkRequest_CanDo> | undefined, b: WorkRequest_CanDo | PlainMessage<WorkRequest_CanDo> | undefined): boolean {
    return proto3.util.equals(WorkRequest_CanDo, a, b);
  }
}

/**
 * @generated from message archivematica.ccp.scheduler.v1.WorkRequest.PreSleep
 */
export class WorkRequest_PreSleep extends Message<WorkRequest_PreSleep> {
  constructor(data?: PartialMessage<WorkRequest_PreSleep>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "archivematica.ccp.scheduler.v1.WorkRequest.PreSleep";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkRequest_PreSleep {
    return new WorkRequest_PreSleep().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkRequest_PreSleep {
    return new WorkRequest_PreSleep().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkRequest_PreSleep {
    return new WorkRequest_PreSleep().fromJsonString(jsonString, options);
  }

  static equals(a: WorkRequest_PreSleep | PlainMessage<WorkRequest_PreSleep> | undefined, b: WorkRequest_PreSleep | PlainMessage<WorkRequest_PreSleep> | undefined): boolean {
    return proto3.util.equals(WorkRequest_PreSleep, a, b);
  }
}

/**
 * @generated from message archivematica.ccp.scheduler.v1.WorkRequest.GrabJob
 */
export class WorkRequest_GrabJob extends Message<WorkRequest_GrabJob> {
  constructor(data?: PartialMessage<WorkRequest_GrabJob>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "archivematica.ccp.scheduler.v1.WorkRequest.GrabJob";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkRequest_GrabJob {
    return new WorkRequest_GrabJob().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkRequest_GrabJob {
    return new WorkRequest_GrabJob().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkRequest_GrabJob {
    return new WorkRequest_GrabJob().fromJsonString(jsonString, options);
  }

  static equals(a: WorkRequest_GrabJob | PlainMessage<WorkRequest_GrabJob> | undefined, b: WorkRequest_GrabJob | PlainMessage<WorkRequest_GrabJob> | undefined): boolean {
    return proto3.util.equals(WorkRequest_GrabJob, a, b);
  }
}

/**
 * @generated from message archivematica.ccp.scheduler.v1.WorkRequest.SetClientId
 */
export class WorkRequest_SetClientId extends Message<WorkRequest_SetClientId> {
  /**
   * @generated from field: string client_id = 1;
   */
  clientId = "";

  constructor(data?: PartialMessage<WorkRequest_SetClientId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "archivematica.ccp.scheduler.v1.WorkRequest.SetClientId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkRequest_SetClientId {
    return new WorkRequest_SetClientId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkRequest_SetClientId {
    return new WorkRequest_SetClientId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkRequest_SetClientId {
    return new WorkRequest_SetClientId().fromJsonString(jsonString, options);
  }

  static equals(a: WorkRequest_SetClientId | PlainMessage<WorkRequest_SetClientId> | undefined, b: WorkRequest_SetClientId | PlainMessage<WorkRequest_SetClientId> | undefined): boolean {
    return proto3.util.equals(WorkRequest_SetClientId, a, b);
  }
}

/**
 * WorkResponse is sent by the scheduler.
 *
 * @generated from message archivematica.ccp.scheduler.v1.WorkResponse
 */
export class WorkResponse extends Message<WorkResponse> {
  /**
   * @generated from oneof archivematica.ccp.scheduler.v1.WorkResponse.response
   */
  response: {
    /**
     * NOOP - wake up a sleeping worker so that it may grab a pending job.
     *
     * @generated from field: archivematica.ccp.scheduler.v1.WorkResponse.NoOp no_op = 1;
     */
    value: WorkResponse_NoOp;
    case: "noOp";
  } | {
    /**
     * NO_JOB - in response to a GRAB_JOB request to notify the worker there are no pending jobs that need to run.
     *
     * @generated from field: archivematica.ccp.scheduler.v1.WorkResponse.NoJob no_job = 2;
     */
    value: WorkResponse_NoJob;
    case: "noJob";
  } | {
    /**
     * JOB_ASSIGN - in response to a GRAB_JOB request to give the worker information needed to run the job.
     *
     * @generated from field: archivematica.ccp.scheduler.v1.WorkResponse.JobAssign job_assign = 3;
     */
    value: WorkResponse_JobAssign;
    case: "jobAssign";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<WorkResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "archivematica.ccp.scheduler.v1.WorkResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "no_op", kind: "message", T: WorkResponse_NoOp, oneof: "response" },
    { no: 2, name: "no_job", kind: "message", T: WorkResponse_NoJob, oneof: "response" },
    { no: 3, name: "job_assign", kind: "message", T: WorkResponse_JobAssign, oneof: "response" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkResponse {
    return new WorkResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkResponse {
    return new WorkResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkResponse {
    return new WorkResponse().fromJsonString(jsonString, options);
  }

  static equals(a: WorkResponse | PlainMessage<WorkResponse> | undefined, b: WorkResponse | PlainMessage<WorkResponse> | undefined): boolean {
    return proto3.util.equals(WorkResponse, a, b);
  }
}

/**
 * @generated from message archivematica.ccp.scheduler.v1.WorkResponse.NoOp
 */
export class WorkResponse_NoOp extends Message<WorkResponse_NoOp> {
  constructor(data?: PartialMessage<WorkResponse_NoOp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "archivematica.ccp.scheduler.v1.WorkResponse.NoOp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkResponse_NoOp {
    return new WorkResponse_NoOp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkResponse_NoOp {
    return new WorkResponse_NoOp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkResponse_NoOp {
    return new WorkResponse_NoOp().fromJsonString(jsonString, options);
  }

  static equals(a: WorkResponse_NoOp | PlainMessage<WorkResponse_NoOp> | undefined, b: WorkResponse_NoOp | PlainMessage<WorkResponse_NoOp> | undefined): boolean {
    return proto3.util.equals(WorkResponse_NoOp, a, b);
  }
}

/**
 * @generated from message archivematica.ccp.scheduler.v1.WorkResponse.NoJob
 */
export class WorkResponse_NoJob extends Message<WorkResponse_NoJob> {
  constructor(data?: PartialMessage<WorkResponse_NoJob>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "archivematica.ccp.scheduler.v1.WorkResponse.NoJob";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkResponse_NoJob {
    return new WorkResponse_NoJob().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkResponse_NoJob {
    return new WorkResponse_NoJob().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkResponse_NoJob {
    return new WorkResponse_NoJob().fromJsonString(jsonString, options);
  }

  static equals(a: WorkResponse_NoJob | PlainMessage<WorkResponse_NoJob> | undefined, b: WorkResponse_NoJob | PlainMessage<WorkResponse_NoJob> | undefined): boolean {
    return proto3.util.equals(WorkResponse_NoJob, a, b);
  }
}

/**
 * @generated from message archivematica.ccp.scheduler.v1.WorkResponse.JobAssign
 */
export class WorkResponse_JobAssign extends Message<WorkResponse_JobAssign> {
  /**
   * Job handle, a unique identifier for the job
   *
   * @generated from field: string job_handle = 1;
   */
  jobHandle = "";

  /**
   * Name of the function the worker should perform
   *
   * @generated from field: string function_name = 2;
   */
  functionName = "";

  /**
   * Workload for the job, can be binary data
   *
   * @generated from field: bytes workload = 3;
   */
  workload = new Uint8Array(0);

  constructor(data?: PartialMessage<WorkResponse_JobAssign>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "archivematica.ccp.scheduler.v1.WorkResponse.JobAssign";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_handle", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "function_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "workload", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkResponse_JobAssign {
    return new WorkResponse_JobAssign().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkResponse_JobAssign {
    return new WorkResponse_JobAssign().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkResponse_JobAssign {
    return new WorkResponse_JobAssign().fromJsonString(jsonString, options);
  }

  static equals(a: WorkResponse_JobAssign | PlainMessage<WorkResponse_JobAssign> | undefined, b: WorkResponse_JobAssign | PlainMessage<WorkResponse_JobAssign> | undefined): boolean {
    return proto3.util.equals(WorkResponse_JobAssign, a, b);
  }
}

