// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/store/store.go
//
// Generated by this command:
//
//	mockgen -typed -source=./internal/store/store.go -destination=./internal/store/storemock/mock_store.go -package=storemock Store
//

// Package storemock is a generated GoMock package.
package storemock

import (
	context "context"
	reflect "reflect"

	adminv1beta1 "github.com/artefactual-labs/ccp/internal/api/gen/archivematica/ccp/admin/v1beta1"
	store "github.com/artefactual-labs/ccp/internal/store"
	enums "github.com/artefactual-labs/ccp/internal/store/enums"
	sqlcmysql "github.com/artefactual-labs/ccp/internal/store/sqlcmysql"
	uuid "github.com/google/uuid"
	gomock "go.uber.org/mock/gomock"
)

// MockStore is a mock of Store interface.
type MockStore struct {
	ctrl     *gomock.Controller
	recorder *MockStoreMockRecorder
	isgomock struct{}
}

// MockStoreMockRecorder is the mock recorder for MockStore.
type MockStoreMockRecorder struct {
	mock *MockStore
}

// NewMockStore creates a new mock instance.
func NewMockStore(ctrl *gomock.Controller) *MockStore {
	mock := &MockStore{ctrl: ctrl}
	mock.recorder = &MockStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStore) EXPECT() *MockStoreMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockStore) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockStoreMockRecorder) Close() *MockStoreCloseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockStore)(nil).Close))
	return &MockStoreCloseCall{Call: call}
}

// MockStoreCloseCall wrap *gomock.Call
type MockStoreCloseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreCloseCall) Return(arg0 error) *MockStoreCloseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreCloseCall) Do(f func() error) *MockStoreCloseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreCloseCall) DoAndReturn(f func() error) *MockStoreCloseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateJob mocks base method.
func (m *MockStore) CreateJob(ctx context.Context, params *sqlcmysql.CreateJobParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateJob", ctx, params)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateJob indicates an expected call of CreateJob.
func (mr *MockStoreMockRecorder) CreateJob(ctx, params any) *MockStoreCreateJobCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateJob", reflect.TypeOf((*MockStore)(nil).CreateJob), ctx, params)
	return &MockStoreCreateJobCall{Call: call}
}

// MockStoreCreateJobCall wrap *gomock.Call
type MockStoreCreateJobCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreCreateJobCall) Return(arg0 error) *MockStoreCreateJobCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreCreateJobCall) Do(f func(context.Context, *sqlcmysql.CreateJobParams) error) *MockStoreCreateJobCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreCreateJobCall) DoAndReturn(f func(context.Context, *sqlcmysql.CreateJobParams) error) *MockStoreCreateJobCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateTasks mocks base method.
func (m *MockStore) CreateTasks(ctx context.Context, tasks []*store.Task) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateTasks", ctx, tasks)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateTasks indicates an expected call of CreateTasks.
func (mr *MockStoreMockRecorder) CreateTasks(ctx, tasks any) *MockStoreCreateTasksCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTasks", reflect.TypeOf((*MockStore)(nil).CreateTasks), ctx, tasks)
	return &MockStoreCreateTasksCall{Call: call}
}

// MockStoreCreateTasksCall wrap *gomock.Call
type MockStoreCreateTasksCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreCreateTasksCall) Return(arg0 error) *MockStoreCreateTasksCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreCreateTasksCall) Do(f func(context.Context, []*store.Task) error) *MockStoreCreateTasksCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreCreateTasksCall) DoAndReturn(f func(context.Context, []*store.Task) error) *MockStoreCreateTasksCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateTransfer mocks base method.
func (m *MockStore) CreateTransfer(ctx context.Context, id uuid.UUID, accessionID, accessSystemID string, metadataSetID uuid.UUID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateTransfer", ctx, id, accessionID, accessSystemID, metadataSetID)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateTransfer indicates an expected call of CreateTransfer.
func (mr *MockStoreMockRecorder) CreateTransfer(ctx, id, accessionID, accessSystemID, metadataSetID any) *MockStoreCreateTransferCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTransfer", reflect.TypeOf((*MockStore)(nil).CreateTransfer), ctx, id, accessionID, accessSystemID, metadataSetID)
	return &MockStoreCreateTransferCall{Call: call}
}

// MockStoreCreateTransferCall wrap *gomock.Call
type MockStoreCreateTransferCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreCreateTransferCall) Return(arg0 error) *MockStoreCreateTransferCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreCreateTransferCall) Do(f func(context.Context, uuid.UUID, string, string, uuid.UUID) error) *MockStoreCreateTransferCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreCreateTransferCall) DoAndReturn(f func(context.Context, uuid.UUID, string, string, uuid.UUID) error) *MockStoreCreateTransferCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateUnitVar mocks base method.
func (m *MockStore) CreateUnitVar(ctx context.Context, id uuid.UUID, packageType enums.PackageType, name, value string, linkID uuid.UUID, update bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateUnitVar", ctx, id, packageType, name, value, linkID, update)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateUnitVar indicates an expected call of CreateUnitVar.
func (mr *MockStoreMockRecorder) CreateUnitVar(ctx, id, packageType, name, value, linkID, update any) *MockStoreCreateUnitVarCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUnitVar", reflect.TypeOf((*MockStore)(nil).CreateUnitVar), ctx, id, packageType, name, value, linkID, update)
	return &MockStoreCreateUnitVarCall{Call: call}
}

// MockStoreCreateUnitVarCall wrap *gomock.Call
type MockStoreCreateUnitVarCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreCreateUnitVarCall) Return(arg0 error) *MockStoreCreateUnitVarCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreCreateUnitVarCall) Do(f func(context.Context, uuid.UUID, enums.PackageType, string, string, uuid.UUID, bool) error) *MockStoreCreateUnitVarCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreCreateUnitVarCall) DoAndReturn(f func(context.Context, uuid.UUID, enums.PackageType, string, string, uuid.UUID, bool) error) *MockStoreCreateUnitVarCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// EnsureDIP mocks base method.
func (m *MockStore) EnsureDIP(ctx context.Context, path string) (uuid.UUID, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EnsureDIP", ctx, path)
	ret0, _ := ret[0].(uuid.UUID)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// EnsureDIP indicates an expected call of EnsureDIP.
func (mr *MockStoreMockRecorder) EnsureDIP(ctx, path any) *MockStoreEnsureDIPCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnsureDIP", reflect.TypeOf((*MockStore)(nil).EnsureDIP), ctx, path)
	return &MockStoreEnsureDIPCall{Call: call}
}

// MockStoreEnsureDIPCall wrap *gomock.Call
type MockStoreEnsureDIPCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreEnsureDIPCall) Return(id uuid.UUID, created bool, err error) *MockStoreEnsureDIPCall {
	c.Call = c.Call.Return(id, created, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreEnsureDIPCall) Do(f func(context.Context, string) (uuid.UUID, bool, error)) *MockStoreEnsureDIPCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreEnsureDIPCall) DoAndReturn(f func(context.Context, string) (uuid.UUID, bool, error)) *MockStoreEnsureDIPCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// EnsureSIP mocks base method.
func (m *MockStore) EnsureSIP(ctx context.Context, path string) (uuid.UUID, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EnsureSIP", ctx, path)
	ret0, _ := ret[0].(uuid.UUID)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// EnsureSIP indicates an expected call of EnsureSIP.
func (mr *MockStoreMockRecorder) EnsureSIP(ctx, path any) *MockStoreEnsureSIPCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnsureSIP", reflect.TypeOf((*MockStore)(nil).EnsureSIP), ctx, path)
	return &MockStoreEnsureSIPCall{Call: call}
}

// MockStoreEnsureSIPCall wrap *gomock.Call
type MockStoreEnsureSIPCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreEnsureSIPCall) Return(id uuid.UUID, created bool, err error) *MockStoreEnsureSIPCall {
	c.Call = c.Call.Return(id, created, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreEnsureSIPCall) Do(f func(context.Context, string) (uuid.UUID, bool, error)) *MockStoreEnsureSIPCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreEnsureSIPCall) DoAndReturn(f func(context.Context, string) (uuid.UUID, bool, error)) *MockStoreEnsureSIPCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// EnsureTransfer mocks base method.
func (m *MockStore) EnsureTransfer(ctx context.Context, path string) (uuid.UUID, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EnsureTransfer", ctx, path)
	ret0, _ := ret[0].(uuid.UUID)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// EnsureTransfer indicates an expected call of EnsureTransfer.
func (mr *MockStoreMockRecorder) EnsureTransfer(ctx, path any) *MockStoreEnsureTransferCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnsureTransfer", reflect.TypeOf((*MockStore)(nil).EnsureTransfer), ctx, path)
	return &MockStoreEnsureTransferCall{Call: call}
}

// MockStoreEnsureTransferCall wrap *gomock.Call
type MockStoreEnsureTransferCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreEnsureTransferCall) Return(id uuid.UUID, created bool, err error) *MockStoreEnsureTransferCall {
	c.Call = c.Call.Return(id, created, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreEnsureTransferCall) Do(f func(context.Context, string) (uuid.UUID, bool, error)) *MockStoreEnsureTransferCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreEnsureTransferCall) DoAndReturn(f func(context.Context, string) (uuid.UUID, bool, error)) *MockStoreEnsureTransferCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Files mocks base method.
func (m *MockStore) Files(ctx context.Context, id uuid.UUID, packageType enums.PackageType, filterFilenameEnd, filterSubdir, replacementPath string) ([]store.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Files", ctx, id, packageType, filterFilenameEnd, filterSubdir, replacementPath)
	ret0, _ := ret[0].([]store.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Files indicates an expected call of Files.
func (mr *MockStoreMockRecorder) Files(ctx, id, packageType, filterFilenameEnd, filterSubdir, replacementPath any) *MockStoreFilesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Files", reflect.TypeOf((*MockStore)(nil).Files), ctx, id, packageType, filterFilenameEnd, filterSubdir, replacementPath)
	return &MockStoreFilesCall{Call: call}
}

// MockStoreFilesCall wrap *gomock.Call
type MockStoreFilesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreFilesCall) Return(arg0 []store.File, arg1 error) *MockStoreFilesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreFilesCall) Do(f func(context.Context, uuid.UUID, enums.PackageType, string, string, string) ([]store.File, error)) *MockStoreFilesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreFilesCall) DoAndReturn(f func(context.Context, uuid.UUID, enums.PackageType, string, string, string) ([]store.File, error)) *MockStoreFilesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FindAwaitingJob mocks base method.
func (m *MockStore) FindAwaitingJob(ctx context.Context, params *store.FindAwaitingJobParams) (*adminv1beta1.Job, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindAwaitingJob", ctx, params)
	ret0, _ := ret[0].(*adminv1beta1.Job)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindAwaitingJob indicates an expected call of FindAwaitingJob.
func (mr *MockStoreMockRecorder) FindAwaitingJob(ctx, params any) *MockStoreFindAwaitingJobCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAwaitingJob", reflect.TypeOf((*MockStore)(nil).FindAwaitingJob), ctx, params)
	return &MockStoreFindAwaitingJobCall{Call: call}
}

// MockStoreFindAwaitingJobCall wrap *gomock.Call
type MockStoreFindAwaitingJobCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreFindAwaitingJobCall) Return(arg0 *adminv1beta1.Job, arg1 error) *MockStoreFindAwaitingJobCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreFindAwaitingJobCall) Do(f func(context.Context, *store.FindAwaitingJobParams) (*adminv1beta1.Job, error)) *MockStoreFindAwaitingJobCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreFindAwaitingJobCall) DoAndReturn(f func(context.Context, *store.FindAwaitingJobParams) (*adminv1beta1.Job, error)) *MockStoreFindAwaitingJobCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListJobs mocks base method.
func (m *MockStore) ListJobs(ctx context.Context, pkgID uuid.UUID) ([]*adminv1beta1.Job, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListJobs", ctx, pkgID)
	ret0, _ := ret[0].([]*adminv1beta1.Job)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListJobs indicates an expected call of ListJobs.
func (mr *MockStoreMockRecorder) ListJobs(ctx, pkgID any) *MockStoreListJobsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListJobs", reflect.TypeOf((*MockStore)(nil).ListJobs), ctx, pkgID)
	return &MockStoreListJobsCall{Call: call}
}

// MockStoreListJobsCall wrap *gomock.Call
type MockStoreListJobsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreListJobsCall) Return(arg0 []*adminv1beta1.Job, arg1 error) *MockStoreListJobsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreListJobsCall) Do(f func(context.Context, uuid.UUID) ([]*adminv1beta1.Job, error)) *MockStoreListJobsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreListJobsCall) DoAndReturn(f func(context.Context, uuid.UUID) ([]*adminv1beta1.Job, error)) *MockStoreListJobsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadDIP mocks base method.
func (m *MockStore) ReadDIP(ctx context.Context, id uuid.UUID) (store.DIP, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadDIP", ctx, id)
	ret0, _ := ret[0].(store.DIP)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadDIP indicates an expected call of ReadDIP.
func (mr *MockStoreMockRecorder) ReadDIP(ctx, id any) *MockStoreReadDIPCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadDIP", reflect.TypeOf((*MockStore)(nil).ReadDIP), ctx, id)
	return &MockStoreReadDIPCall{Call: call}
}

// MockStoreReadDIPCall wrap *gomock.Call
type MockStoreReadDIPCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreReadDIPCall) Return(dip store.DIP, err error) *MockStoreReadDIPCall {
	c.Call = c.Call.Return(dip, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreReadDIPCall) Do(f func(context.Context, uuid.UUID) (store.DIP, error)) *MockStoreReadDIPCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreReadDIPCall) DoAndReturn(f func(context.Context, uuid.UUID) (store.DIP, error)) *MockStoreReadDIPCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadDict mocks base method.
func (m *MockStore) ReadDict(ctx context.Context, name string) (map[string]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadDict", ctx, name)
	ret0, _ := ret[0].(map[string]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadDict indicates an expected call of ReadDict.
func (mr *MockStoreMockRecorder) ReadDict(ctx, name any) *MockStoreReadDictCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadDict", reflect.TypeOf((*MockStore)(nil).ReadDict), ctx, name)
	return &MockStoreReadDictCall{Call: call}
}

// MockStoreReadDictCall wrap *gomock.Call
type MockStoreReadDictCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreReadDictCall) Return(arg0 map[string]string, arg1 error) *MockStoreReadDictCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreReadDictCall) Do(f func(context.Context, string) (map[string]string, error)) *MockStoreReadDictCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreReadDictCall) DoAndReturn(f func(context.Context, string) (map[string]string, error)) *MockStoreReadDictCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadPackagesWithCreationTimestamps mocks base method.
func (m *MockStore) ReadPackagesWithCreationTimestamps(ctx context.Context, packageType adminv1beta1.PackageType) ([]*adminv1beta1.Package, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadPackagesWithCreationTimestamps", ctx, packageType)
	ret0, _ := ret[0].([]*adminv1beta1.Package)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadPackagesWithCreationTimestamps indicates an expected call of ReadPackagesWithCreationTimestamps.
func (mr *MockStoreMockRecorder) ReadPackagesWithCreationTimestamps(ctx, packageType any) *MockStoreReadPackagesWithCreationTimestampsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadPackagesWithCreationTimestamps", reflect.TypeOf((*MockStore)(nil).ReadPackagesWithCreationTimestamps), ctx, packageType)
	return &MockStoreReadPackagesWithCreationTimestampsCall{Call: call}
}

// MockStoreReadPackagesWithCreationTimestampsCall wrap *gomock.Call
type MockStoreReadPackagesWithCreationTimestampsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreReadPackagesWithCreationTimestampsCall) Return(arg0 []*adminv1beta1.Package, arg1 error) *MockStoreReadPackagesWithCreationTimestampsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreReadPackagesWithCreationTimestampsCall) Do(f func(context.Context, adminv1beta1.PackageType) ([]*adminv1beta1.Package, error)) *MockStoreReadPackagesWithCreationTimestampsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreReadPackagesWithCreationTimestampsCall) DoAndReturn(f func(context.Context, adminv1beta1.PackageType) ([]*adminv1beta1.Package, error)) *MockStoreReadPackagesWithCreationTimestampsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadPipelineID mocks base method.
func (m *MockStore) ReadPipelineID(ctx context.Context) (uuid.UUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadPipelineID", ctx)
	ret0, _ := ret[0].(uuid.UUID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadPipelineID indicates an expected call of ReadPipelineID.
func (mr *MockStoreMockRecorder) ReadPipelineID(ctx any) *MockStoreReadPipelineIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadPipelineID", reflect.TypeOf((*MockStore)(nil).ReadPipelineID), ctx)
	return &MockStoreReadPipelineIDCall{Call: call}
}

// MockStoreReadPipelineIDCall wrap *gomock.Call
type MockStoreReadPipelineIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreReadPipelineIDCall) Return(arg0 uuid.UUID, arg1 error) *MockStoreReadPipelineIDCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreReadPipelineIDCall) Do(f func(context.Context) (uuid.UUID, error)) *MockStoreReadPipelineIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreReadPipelineIDCall) DoAndReturn(f func(context.Context) (uuid.UUID, error)) *MockStoreReadPipelineIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadSIP mocks base method.
func (m *MockStore) ReadSIP(ctx context.Context, id uuid.UUID) (store.SIP, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadSIP", ctx, id)
	ret0, _ := ret[0].(store.SIP)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadSIP indicates an expected call of ReadSIP.
func (mr *MockStoreMockRecorder) ReadSIP(ctx, id any) *MockStoreReadSIPCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadSIP", reflect.TypeOf((*MockStore)(nil).ReadSIP), ctx, id)
	return &MockStoreReadSIPCall{Call: call}
}

// MockStoreReadSIPCall wrap *gomock.Call
type MockStoreReadSIPCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreReadSIPCall) Return(sip store.SIP, err error) *MockStoreReadSIPCall {
	c.Call = c.Call.Return(sip, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreReadSIPCall) Do(f func(context.Context, uuid.UUID) (store.SIP, error)) *MockStoreReadSIPCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreReadSIPCall) DoAndReturn(f func(context.Context, uuid.UUID) (store.SIP, error)) *MockStoreReadSIPCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadTransfer mocks base method.
func (m *MockStore) ReadTransfer(ctx context.Context, id uuid.UUID) (store.Transfer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadTransfer", ctx, id)
	ret0, _ := ret[0].(store.Transfer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadTransfer indicates an expected call of ReadTransfer.
func (mr *MockStoreMockRecorder) ReadTransfer(ctx, id any) *MockStoreReadTransferCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadTransfer", reflect.TypeOf((*MockStore)(nil).ReadTransfer), ctx, id)
	return &MockStoreReadTransferCall{Call: call}
}

// MockStoreReadTransferCall wrap *gomock.Call
type MockStoreReadTransferCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreReadTransferCall) Return(transfer store.Transfer, err error) *MockStoreReadTransferCall {
	c.Call = c.Call.Return(transfer, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreReadTransferCall) Do(f func(context.Context, uuid.UUID) (store.Transfer, error)) *MockStoreReadTransferCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreReadTransferCall) DoAndReturn(f func(context.Context, uuid.UUID) (store.Transfer, error)) *MockStoreReadTransferCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadTransferLocation mocks base method.
func (m *MockStore) ReadTransferLocation(ctx context.Context, id uuid.UUID) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadTransferLocation", ctx, id)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadTransferLocation indicates an expected call of ReadTransferLocation.
func (mr *MockStoreMockRecorder) ReadTransferLocation(ctx, id any) *MockStoreReadTransferLocationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadTransferLocation", reflect.TypeOf((*MockStore)(nil).ReadTransferLocation), ctx, id)
	return &MockStoreReadTransferLocationCall{Call: call}
}

// MockStoreReadTransferLocationCall wrap *gomock.Call
type MockStoreReadTransferLocationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreReadTransferLocationCall) Return(loc string, err error) *MockStoreReadTransferLocationCall {
	c.Call = c.Call.Return(loc, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreReadTransferLocationCall) Do(f func(context.Context, uuid.UUID) (string, error)) *MockStoreReadTransferLocationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreReadTransferLocationCall) DoAndReturn(f func(context.Context, uuid.UUID) (string, error)) *MockStoreReadTransferLocationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadUnitLinkID mocks base method.
func (m *MockStore) ReadUnitLinkID(ctx context.Context, id uuid.UUID, packageType enums.PackageType, name string) (uuid.UUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadUnitLinkID", ctx, id, packageType, name)
	ret0, _ := ret[0].(uuid.UUID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadUnitLinkID indicates an expected call of ReadUnitLinkID.
func (mr *MockStoreMockRecorder) ReadUnitLinkID(ctx, id, packageType, name any) *MockStoreReadUnitLinkIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadUnitLinkID", reflect.TypeOf((*MockStore)(nil).ReadUnitLinkID), ctx, id, packageType, name)
	return &MockStoreReadUnitLinkIDCall{Call: call}
}

// MockStoreReadUnitLinkIDCall wrap *gomock.Call
type MockStoreReadUnitLinkIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreReadUnitLinkIDCall) Return(arg0 uuid.UUID, arg1 error) *MockStoreReadUnitLinkIDCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreReadUnitLinkIDCall) Do(f func(context.Context, uuid.UUID, enums.PackageType, string) (uuid.UUID, error)) *MockStoreReadUnitLinkIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreReadUnitLinkIDCall) DoAndReturn(f func(context.Context, uuid.UUID, enums.PackageType, string) (uuid.UUID, error)) *MockStoreReadUnitLinkIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadUnitVar mocks base method.
func (m *MockStore) ReadUnitVar(ctx context.Context, id uuid.UUID, packageType enums.PackageType, name string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadUnitVar", ctx, id, packageType, name)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadUnitVar indicates an expected call of ReadUnitVar.
func (mr *MockStoreMockRecorder) ReadUnitVar(ctx, id, packageType, name any) *MockStoreReadUnitVarCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadUnitVar", reflect.TypeOf((*MockStore)(nil).ReadUnitVar), ctx, id, packageType, name)
	return &MockStoreReadUnitVarCall{Call: call}
}

// MockStoreReadUnitVarCall wrap *gomock.Call
type MockStoreReadUnitVarCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreReadUnitVarCall) Return(arg0 string, arg1 error) *MockStoreReadUnitVarCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreReadUnitVarCall) Do(f func(context.Context, uuid.UUID, enums.PackageType, string) (string, error)) *MockStoreReadUnitVarCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreReadUnitVarCall) DoAndReturn(f func(context.Context, uuid.UUID, enums.PackageType, string) (string, error)) *MockStoreReadUnitVarCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadUnitVars mocks base method.
func (m *MockStore) ReadUnitVars(ctx context.Context, id uuid.UUID, packageType enums.PackageType, name string) ([]store.UnitVar, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadUnitVars", ctx, id, packageType, name)
	ret0, _ := ret[0].([]store.UnitVar)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadUnitVars indicates an expected call of ReadUnitVars.
func (mr *MockStoreMockRecorder) ReadUnitVars(ctx, id, packageType, name any) *MockStoreReadUnitVarsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadUnitVars", reflect.TypeOf((*MockStore)(nil).ReadUnitVars), ctx, id, packageType, name)
	return &MockStoreReadUnitVarsCall{Call: call}
}

// MockStoreReadUnitVarsCall wrap *gomock.Call
type MockStoreReadUnitVarsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreReadUnitVarsCall) Return(arg0 []store.UnitVar, arg1 error) *MockStoreReadUnitVarsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreReadUnitVarsCall) Do(f func(context.Context, uuid.UUID, enums.PackageType, string) ([]store.UnitVar, error)) *MockStoreReadUnitVarsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreReadUnitVarsCall) DoAndReturn(f func(context.Context, uuid.UUID, enums.PackageType, string) ([]store.UnitVar, error)) *MockStoreReadUnitVarsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RemoveTransientData mocks base method.
func (m *MockStore) RemoveTransientData(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveTransientData", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveTransientData indicates an expected call of RemoveTransientData.
func (mr *MockStoreMockRecorder) RemoveTransientData(ctx any) *MockStoreRemoveTransientDataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveTransientData", reflect.TypeOf((*MockStore)(nil).RemoveTransientData), ctx)
	return &MockStoreRemoveTransientDataCall{Call: call}
}

// MockStoreRemoveTransientDataCall wrap *gomock.Call
type MockStoreRemoveTransientDataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreRemoveTransientDataCall) Return(arg0 error) *MockStoreRemoveTransientDataCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreRemoveTransientDataCall) Do(f func(context.Context) error) *MockStoreRemoveTransientDataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreRemoveTransientDataCall) DoAndReturn(f func(context.Context) error) *MockStoreRemoveTransientDataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Running mocks base method.
func (m *MockStore) Running() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Running")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Running indicates an expected call of Running.
func (mr *MockStoreMockRecorder) Running() *MockStoreRunningCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Running", reflect.TypeOf((*MockStore)(nil).Running))
	return &MockStoreRunningCall{Call: call}
}

// MockStoreRunningCall wrap *gomock.Call
type MockStoreRunningCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreRunningCall) Return(arg0 bool) *MockStoreRunningCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreRunningCall) Do(f func() bool) *MockStoreRunningCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreRunningCall) DoAndReturn(f func() bool) *MockStoreRunningCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateJobStatus mocks base method.
func (m *MockStore) UpdateJobStatus(ctx context.Context, id uuid.UUID, status string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateJobStatus", ctx, id, status)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateJobStatus indicates an expected call of UpdateJobStatus.
func (mr *MockStoreMockRecorder) UpdateJobStatus(ctx, id, status any) *MockStoreUpdateJobStatusCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateJobStatus", reflect.TypeOf((*MockStore)(nil).UpdateJobStatus), ctx, id, status)
	return &MockStoreUpdateJobStatusCall{Call: call}
}

// MockStoreUpdateJobStatusCall wrap *gomock.Call
type MockStoreUpdateJobStatusCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreUpdateJobStatusCall) Return(arg0 error) *MockStoreUpdateJobStatusCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreUpdateJobStatusCall) Do(f func(context.Context, uuid.UUID, string) error) *MockStoreUpdateJobStatusCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreUpdateJobStatusCall) DoAndReturn(f func(context.Context, uuid.UUID, string) error) *MockStoreUpdateJobStatusCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdatePackageStatus mocks base method.
func (m *MockStore) UpdatePackageStatus(ctx context.Context, id uuid.UUID, packageType enums.PackageType, status enums.PackageStatus) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdatePackageStatus", ctx, id, packageType, status)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdatePackageStatus indicates an expected call of UpdatePackageStatus.
func (mr *MockStoreMockRecorder) UpdatePackageStatus(ctx, id, packageType, status any) *MockStoreUpdatePackageStatusCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdatePackageStatus", reflect.TypeOf((*MockStore)(nil).UpdatePackageStatus), ctx, id, packageType, status)
	return &MockStoreUpdatePackageStatusCall{Call: call}
}

// MockStoreUpdatePackageStatusCall wrap *gomock.Call
type MockStoreUpdatePackageStatusCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreUpdatePackageStatusCall) Return(arg0 error) *MockStoreUpdatePackageStatusCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreUpdatePackageStatusCall) Do(f func(context.Context, uuid.UUID, enums.PackageType, enums.PackageStatus) error) *MockStoreUpdatePackageStatusCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreUpdatePackageStatusCall) DoAndReturn(f func(context.Context, uuid.UUID, enums.PackageType, enums.PackageStatus) error) *MockStoreUpdatePackageStatusCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateTransferLocation mocks base method.
func (m *MockStore) UpdateTransferLocation(ctx context.Context, id uuid.UUID, path string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateTransferLocation", ctx, id, path)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateTransferLocation indicates an expected call of UpdateTransferLocation.
func (mr *MockStoreMockRecorder) UpdateTransferLocation(ctx, id, path any) *MockStoreUpdateTransferLocationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateTransferLocation", reflect.TypeOf((*MockStore)(nil).UpdateTransferLocation), ctx, id, path)
	return &MockStoreUpdateTransferLocationCall{Call: call}
}

// MockStoreUpdateTransferLocationCall wrap *gomock.Call
type MockStoreUpdateTransferLocationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreUpdateTransferLocationCall) Return(arg0 error) *MockStoreUpdateTransferLocationCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreUpdateTransferLocationCall) Do(f func(context.Context, uuid.UUID, string) error) *MockStoreUpdateTransferLocationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreUpdateTransferLocationCall) DoAndReturn(f func(context.Context, uuid.UUID, string) error) *MockStoreUpdateTransferLocationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpsertDIP mocks base method.
func (m *MockStore) UpsertDIP(ctx context.Context, id uuid.UUID, path string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpsertDIP", ctx, id, path)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpsertDIP indicates an expected call of UpsertDIP.
func (mr *MockStoreMockRecorder) UpsertDIP(ctx, id, path any) *MockStoreUpsertDIPCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertDIP", reflect.TypeOf((*MockStore)(nil).UpsertDIP), ctx, id, path)
	return &MockStoreUpsertDIPCall{Call: call}
}

// MockStoreUpsertDIPCall wrap *gomock.Call
type MockStoreUpsertDIPCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreUpsertDIPCall) Return(created bool, err error) *MockStoreUpsertDIPCall {
	c.Call = c.Call.Return(created, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreUpsertDIPCall) Do(f func(context.Context, uuid.UUID, string) (bool, error)) *MockStoreUpsertDIPCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreUpsertDIPCall) DoAndReturn(f func(context.Context, uuid.UUID, string) (bool, error)) *MockStoreUpsertDIPCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpsertSIP mocks base method.
func (m *MockStore) UpsertSIP(ctx context.Context, id uuid.UUID, path string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpsertSIP", ctx, id, path)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpsertSIP indicates an expected call of UpsertSIP.
func (mr *MockStoreMockRecorder) UpsertSIP(ctx, id, path any) *MockStoreUpsertSIPCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertSIP", reflect.TypeOf((*MockStore)(nil).UpsertSIP), ctx, id, path)
	return &MockStoreUpsertSIPCall{Call: call}
}

// MockStoreUpsertSIPCall wrap *gomock.Call
type MockStoreUpsertSIPCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreUpsertSIPCall) Return(created bool, err error) *MockStoreUpsertSIPCall {
	c.Call = c.Call.Return(created, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreUpsertSIPCall) Do(f func(context.Context, uuid.UUID, string) (bool, error)) *MockStoreUpsertSIPCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreUpsertSIPCall) DoAndReturn(f func(context.Context, uuid.UUID, string) (bool, error)) *MockStoreUpsertSIPCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpsertTransfer mocks base method.
func (m *MockStore) UpsertTransfer(ctx context.Context, id uuid.UUID, path string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpsertTransfer", ctx, id, path)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpsertTransfer indicates an expected call of UpsertTransfer.
func (mr *MockStoreMockRecorder) UpsertTransfer(ctx, id, path any) *MockStoreUpsertTransferCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertTransfer", reflect.TypeOf((*MockStore)(nil).UpsertTransfer), ctx, id, path)
	return &MockStoreUpsertTransferCall{Call: call}
}

// MockStoreUpsertTransferCall wrap *gomock.Call
type MockStoreUpsertTransferCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreUpsertTransferCall) Return(created bool, err error) *MockStoreUpsertTransferCall {
	c.Call = c.Call.Return(created, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreUpsertTransferCall) Do(f func(context.Context, uuid.UUID, string) (bool, error)) *MockStoreUpsertTransferCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreUpsertTransferCall) DoAndReturn(f func(context.Context, uuid.UUID, string) (bool, error)) *MockStoreUpsertTransferCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ValidateUserAPIKey mocks base method.
func (m *MockStore) ValidateUserAPIKey(ctx context.Context, username, key string) (*store.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ValidateUserAPIKey", ctx, username, key)
	ret0, _ := ret[0].(*store.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ValidateUserAPIKey indicates an expected call of ValidateUserAPIKey.
func (mr *MockStoreMockRecorder) ValidateUserAPIKey(ctx, username, key any) *MockStoreValidateUserAPIKeyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateUserAPIKey", reflect.TypeOf((*MockStore)(nil).ValidateUserAPIKey), ctx, username, key)
	return &MockStoreValidateUserAPIKeyCall{Call: call}
}

// MockStoreValidateUserAPIKeyCall wrap *gomock.Call
type MockStoreValidateUserAPIKeyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStoreValidateUserAPIKeyCall) Return(arg0 *store.User, arg1 error) *MockStoreValidateUserAPIKeyCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStoreValidateUserAPIKeyCall) Do(f func(context.Context, string, string) (*store.User, error)) *MockStoreValidateUserAPIKeyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStoreValidateUserAPIKeyCall) DoAndReturn(f func(context.Context, string, string) (*store.User, error)) *MockStoreValidateUserAPIKeyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
